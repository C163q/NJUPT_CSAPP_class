运行方式: gdb bomb --command="my_data/auto_set"

- <__isoc99_sscanf@plt>
%rdi: 这里面的所有案例都会把你输入的字符串原样传入，作为%rdi。
%rsi: 格式化参数，例如"%d %d"。
可以使用"x/s $rdi"和"x/s $rsi"查看具体值。

- phase_1:
string_length: (%rdi)的字符串的长度
string_not_equal: 比较字符串是否相同
这道题很简单，因为string_not_equal中的%rsi寄存器就存放着正确答案的字符串的地址。
只要使用"x/s $rsi"查看是什么字符串就行了。

- phase_2:
read_six_numbers: 读取6个数字，在其中会调用__isoc99_sscanf@plt，会传入"%d %d %d %d %d %d"读取六个数字，因此首先要确保输入的是六个数字
该函数中，会首先将初值设定为1，并将该值与输入数组的索引0的值比较，此后每向下一索引中的输入值比较，都会把比较值加上等差数列n，也就是比较值为2,4,7,11,16
（确实每个炸弹都不一样，测试炸弹bomb里面是每个都乘以2）

- phase_3:
首先会调用scanf，会传入"%d %c %d"读取两个数字和一个字符
（测试炸弹bomb里面是"%d %d"）
首先会测试会测试第一个输入值是否大于7（无符号），如果成立，就会立刻跳转到explode_bomb，因此只需要输入一个小于等于7的非负数即可，例如：1。
接着会测试第三个输入值是否等于0x1ec，如果成立，则跳转到<phase_3+346>，否则执行explode_bomb，因此第三个值是492。
接着会测试第二个输入值是否等于字符i，如果不成立，则直接跳转到explode_bomb，因此第二个值是i。
所以输入值是: 1 i 492。当然，第一个值你也可以不用1。

- phase_4:
仍然首先调用__isoc99_sscanf@plt，会传入"%d %d"读取两个数字。
接下来就会开始调用func4，func4内部会递归调用自身，我没有找到非常好的思路，所以只能写出这段代码大致的C语言代码：
void phase_4(int input1, int input2) { /* 其中scanf函数读取的两个数字分别为input1和input2 */
    if ((unsigned)input1 >= 14u) explode_bomb();
    int ret = func(input1, 0, 14);
    if (ret != 0x12) explode_bomb();
    if (input2 != 0x12) explode_bomb();
    return;
}

int func4(val1, val2, val3) {
    int ret = val3 - val2;
    int tmp = ((int)(((unsigned)ret >> 31) + ret) >> 1) + val2;
    if (tmp > val1) {
        val3 = tmp - 1;
        int ret1 = func4(val1, val2, val3);
        tmp += ret1;
    }
    else if (tmp < val1) {
        val2 = tmp + 1;
        int ret1 = func4(val1, val2, val3);
        tmp += ret1;
    }
    return tmp;
}
可以看出input1的输入值不能是负数，也不能大于等于14。而input2没有参与递归函数，而是直接明确需要等于0x12。
input1的值是未知的，但在调用递归函数后要求结果为0x12。其实只要暴力遍历0到13，调用函数保证最终输出结果为0x12即可。
最终得到的结果是: 11 18

phase_5:
首先会调用string_length()函数判断输入的字符串的长度，该题要求输入的字符串长度为6。
接着会进入一个循环，这个循环会通过一系列计算将6个数字放入一个长度为7的char类型的数组，数组的最后一位，也就是索引6，在退出循环后会置0。
这个计算过程与输入值有关。假设input是你输入的字符串，而output是根据你的输入结果输出的字符串，最终目标是保证output为"devils"。观察汇编代码其实可以发现，output[i]仅与input[i]有关，因此，可以列出output[i]=F(input[i])。
接下来就是根据汇编代码得到这个F了。首先可以观察到，%rax在0到6之间取值，与数组的索引有关，%rbx存储的应该是用户输入的字符串的指针，"movzbl (%rbx,%rax,1),%edx"就相当于"tmp=input[i]"，之后，会执行"tmp&=0xF"。
可以观察到汇编中做了"lea 0x18d4(%rip),%rcx"的操作，推测是存储映射的数组，由于映射是字符到字符的，使用"x/s $rcx"可以得到"maduiersnfotvbylSo you think you can stop the bomb with ctrl-c, do you?"。
接下来，会执行"movzbl (%rcx,%rdx,1),%edx"，也就是说会从该表中查询索引为%rdx的值存储在%edx中，接着后面的汇编代码会把%dl的值存储在栈内的数组中，也就是output中。最后该会调用string_not_equal()函数，其中，该函数的第一个参数是output，而第二个参数是"devils"。转换成C语言代码描述就是：
void phase_5_partial(const char* input) {
    char table[17] = "maduiersnfotvbyl"; /* 由于做了与运算，因此取到的最大索引值只能是15，此处删除了后面的内容。 */
    char output[7];
    for (int i = 0; i != 6; ++i) {
        int tmp = input[i];
        tmp &= 0xF;
        output[i] = table[tmp];
    }
    output[6] = '\0';
    if (string_not_equal(output, "devils")) explode_bomb();
}
根据上面的分析，可以得到，输入的字符串必须是长度为6的，第一个字符可以是'b'或'r'，第二个字符可以是'e'或'u'，第三个字符是'l'，第四个字符是'd'或者't'，第五个字符是'o'，第六个字符可以是'g'或'w'。

phase_6:
整个函数看上去很长，有很多跳来跳去的地方，但大体可以分为两部分<phase_6+120>之前的部分和<phase_6+120>之后的部分，这样划分的原因是，前一部分只有<phase_6+113>可以跳到后一部分，而后一部分永远不会跳到前一部分。
先总结一下前半段做了什么事情。
在<phase_6>一开始就调用了与<phase_2>中相同的read_six_numbers()函数，用户获取6个数字，这就得到了一条线索，也就是必须输入6个数字，这6个数字会被存入栈中，暂且认为这是数组，并命名为arr。
接着给%r14(后续称为val1)设为1，而%r12(后续称为val2)设为arr的地址，%r13(后续称为val3)设为arr的地址，然后这段代码会跳转到<phase_6+94>。
<phase_6+61>到<phase_6+118>这段代码做检查工作，是嵌套的循环，同样分为两部分。第一部分是从<phase_6+61>到<phase_6+84>的部分，第二部分是从<phase_6+86>到<phase_6+118>的部分。
第二部分是外层循环，会遍历数组中的每一个元素，判断每一个元素是否满足((unsigned)val3[i] - 1 <= 5)，如果不满足，则直接explode_bomb()，也就是说，数组中的每个元素都必须是1到6之间的数字，由于是无符号数判断，因此小于等于0的数都不符合。内层循环会遍历接下来的数字，保证接下来的数字和外层所选的数字不相等，也就是说，输入的6个数字必须互不相同。
以上，我们就可以把答案缩小到数字1,2,3,4,5,6的排列了。
在检查完成之后，代码就会进入后半段。
进入后半段的时候，可以看见一个"# 0x405330 <node1>"的注释，前面的汇编代码是"lea 0x393c(%rip),%rdx"，而执行完这段代码之后，%rdx的值变成了0x405330，这提示我们%rdx是指向链表第一个结点的指针。使用"x/20x $rdx"之后可以看见如下值：
0x405330 <node1>: 0x00000227 0x00000001 0x00405340 0x00000000
0x405340 <node2>: 0x0000017d 0x00000002 0x00405350 0x00000000
0x405350 <node3>: 0x00000200 0x00000003 0x00405360 0x00000000
0x405360 <node4>: 0x00000044 0x00000004 0x00405370 0x00000000
0x405370 <node5>: 0x000003a5 0x00000005 0x00405210 0x00000000
这里我使用的测试值是1,2,3,4,5,6，所以是上述数值。由于linux是小端存储的，所以在看后面的"0x00405340 0x00000000"时，应当视作"0x0000000000405340"。而对于前面的值，可以看到第一列是给定值，而第二列是我们的输入值。
也就是说，结构体node可能是这样定义的：
struct node {
    int preset;
    int value;
    node* next;
};
此外，可以注意到<node5>中的指针指向一个新的不连续的空间，使用"x/4x 0x00405210"查看该位置可以得到：
0x405210 <node6>: 0x00000336 0x00000006 0x00000000 0x00000000
可以看见指针域是空指针，链表就此结束。
从<phase_6+120>到<phase_6+169>这一段也全部都是跳转语句，转换成C语言代码大致如下：
void phase_6_from_120_to_169() {
    node* node_arr = (void*)arr + 0x20;	/* 这其实是栈的一部分 */
    int p2 = 0;
    do {
        int p4 = arr[p2];  /* arr里面的前6个就存储着输入的6个整数 */
        int ret = 1;
        node* p3 = &node1; /* 之前分析的0x405330 <node1> */
        if (p4 > 1) {
            do {
                p3 = p3->next;
                ret += 1;
            }
            while (p4 != ret);
        }
        node_arr[p2] = p3;
        ++p2;
    }
    while (p2 != 6);
}
可以看出来其大致的意思是你输入的值的序列就是结点存储的序列，例如，你输入1,3,6,2,5,4，那么就会依次在node_arr中存储第一个结点，第三个结点，第六个结点……
然后，从<phase+171>到<phase+221>的代码就是让原链表结点按照数组中相邻的结点的顺序依次连接，且最后一个结点元素的指针域置零。
重点在后面，后面的代码中%rbx会从第一个结点开始向后遍历链表，而%rax指向的结点永远会先于%rbx一个，也就是%rax=%rbx->next。而循环中有个判断条件是否满足的位置，如果不满足，则会调用explode_bomb()。
查看判断条件可以发现，它要求(%rbx->preset)>(%rax->preset)，也就是说，它要求链表的结点按照递增的顺序连接，因此可以得出输入值为：4 2 3 1 6 5。

secret_phase:


