运行方式: gdb bomb --command="my_data/auto_set"

- <__isoc99_sscanf@plt>
%rdi: 这里面的所有案例都会把你输入的字符串原样传入，作为%rdi。
%rsi: 格式化参数，例如"%d %d"。
可以使用"x/s $rdi"和"x/s $rsi"查看具体值。

- phase_1:
string_length: (%rdi)的字符串的长度
string_not_equal: 比较字符串是否相同
这道题很简单，因为string_not_equal中的%rsi寄存器就存放着正确答案的字符串的地址。
只要使用"x/s $rsi"查看是什么字符串就行了。

- phase_2:
read_six_numbers: 读取6个数字，在其中会调用__isoc99_sscanf@plt，会传入"%d %d %d %d %d %d"读取六个数字，因此首先要确保输入的是六个数字
该函数中，会首先将初值设定为1，并将该值与输入数组的索引0的值比较，此后每向下一索引中的输入值比较，都会把比较值加上等差数列n，也就是比较值为2,4,7,11,16
（确实每个炸弹都不一样，测试炸弹bomb里面是每个都乘以2）

- phase_3:
首先会调用scanf，会传入"%d %c %d"读取两个数字和一个字符
（测试炸弹bomb里面是"%d %d"）
首先会测试会测试第一个输入值是否大于7（无符号），如果成立，就会立刻跳转到explode_bomb，因此只需要输入一个小于等于7的非负数即可，例如：1。
接着会测试第三个输入值是否等于0x1ec，如果成立，则跳转到<phase_3+346>，否则执行explode_bomb，因此第三个值是492。
接着会测试第二个输入值是否等于字符i，如果不成立，则直接跳转到explode_bomb，因此第二个值是i。
所以输入值是: 1 i 492。当然，第一个值你也可以不用1。

- phase_4:
仍然首先调用__isoc99_sscanf@plt，会传入"%d %d"读取两个数字。
接下来就会开始调用func4，func4内部会递归调用自身，我没有找到非常好的思路，所以只能写出这段代码大致的C语言代码：
void phase_4(int input1, int input2) { /* 其中scanf函数读取的两个数字分别为input1和input2 */
    if ((unsigned)input1 >= 14u) explode_bomb();
    int ret = func(input1, 0, 14);
    if (ret != 0x12) explode_bomb();
    if (input2 != 0x12) explode_bomb();
    return;
}

int func4(val1, val2, val3) {
    int ret = val3 - val2;
    int tmp = ((int)(((unsigned)ret >> 31) + ret) >> 1) + val2;
    if (tmp > val1) {
        val3 = tmp - 1;
        int ret1 = func4(val1, val2, val3);
        tmp += ret1;
    }
    else if (tmp < val1) {
        val2 = tmp + 1;
        int ret1 = func4(val1, val2, val3);
        tmp += ret1;
    }
    return tmp;
}
可以看出input1的输入值不能是负数，也不能大于等于14。而input2没有参与递归函数，而是直接明确需要等于0x12。
input1的值是未知的，但在调用递归函数后要求结果为0x12。其实只要暴力遍历0到13，调用函数保证最终输出结果为0x12即可。
最终得到的结果是: 11 18

phase_5:
首先会调用string_length()函数判断输入的字符串的长度，该题要求输入的字符串长度为6。
接着会进入一个循环，这个循环会通过一系列计算将6个数字放入一个长度为7的char类型的数组，数组的最后一位，也就是索引6，在退出循环后会置0。
这个计算过程与输入值有关。假设input是你输入的字符串，而output是根据你的输入结果输出的字符串，最终目标是保证output为"devils"。观察汇编代码其实可以发现，output[i]仅与input[i]有关，因此，可以列出output[i]=F(input[i])。
接下来就是根据汇编代码得到这个F了。首先可以观察到，%rax在0到6之间取值，与数组的索引有关，%rbx存储的应该是用户输入的字符串的指针，"movzbl (%rbx,%rax,1),%edx"就相当于"tmp=input[i]"，之后，会执行"tmp&=0xF"。
可以观察到汇编中做了"lea 0x18d4(%rip),%rcx"的操作，推测是存储映射的数组，由于映射是字符到字符的，使用"x/s $rcx"可以得到"maduiersnfotvbylSo you think you can stop the bomb with ctrl-c, do you?"。
接下来，会执行"movzbl (%rcx,%rdx,1),%edx"，也就是说会从该表中查询索引为%rdx的值存储在%edx中，接着后面的汇编代码会把%dl的值存储在栈内的数组中，也就是output中。最后该会调用string_not_equal()函数，其中，该函数的第一个参数是output，而第二个参数是"devils"。转换成C语言代码描述就是：
void phase_5_partial(const char* input) {
    char table[17] = "maduiersnfotvbyl"; /* 由于做了与运算，因此取到的最大索引值只能是15，此处删除了后面的内容。 */
    char output[7];
    for (int i = 0; i != 6; ++i) {
        int tmp = input[i];
        tmp &= 0xF;
        output[i] = table[tmp];
    }
    output[6] = '\0';
    if (string_not_equal(output, "devils")) explode_bomb();
}
根据上面的分析，可以得到，输入的字符串必须是长度为6的，第一个字符可以是'b'或'r'，第二个字符可以是'e'或'u'，第三个字符是'l'，第四个字符是'd'或者't'，第五个字符是'o'，第六个字符可以是'g'或'w'。

phase_6:
整个函数看上去很长，有很多跳来跳去的地方，但大体可以分为两部分<phase_6+120>之前的部分和<phase_6+120>之后的部分，这样划分的原因是，前一部分只有<phase_6+113>可以跳到后一部分，而后一部分永远不会跳到前一部分。
先总结一下前半段做了什么事情。
在<phase_6>一开始就调用了与<phase_2>中相同的read_six_numbers()函数，用户获取6个数字，这就得到了一条线索，也就是必须输入6个数字，这6个数字会被存入栈中，暂且认为这是数组，并命名为arr。
接着给%r14(后续称为val1)设为1，而%r12(后续称为val2)设为arr的地址，%r13(后续称为val3)设为arr的地址，然后这段代码会跳转到<phase_6+94>。
<phase_6+61>到<phase_6+118>这段代码做检查工作，是嵌套的循环，同样分为两部分。第一部分是从<phase_6+61>到<phase_6+84>的部分，第二部分是从<phase_6+86>到<phase_6+118>的部分。
第二部分是外层循环，会遍历数组中的每一个元素，判断每一个元素是否满足((unsigned)val3[i] - 1 <= 5)，如果不满足，则直接explode_bomb()，也就是说，数组中的每个元素都必须是1到6之间的数字，由于是无符号数判断，因此小于等于0的数都不符合。内层循环会遍历接下来的数字，保证接下来的数字和外层所选的数字不相等，也就是说，输入的6个数字必须互不相同。
以上，我们就可以把答案缩小到数字1,2,3,4,5,6的排列了。
在检查完成之后，代码就会进入后半段。
进入后半段的时候，可以看见一个"# 0x405330 <node1>"的注释，前面的汇编代码是"lea 0x393c(%rip),%rdx"，而执行完这段代码之后，%rdx的值变成了0x405330，这提示我们%rdx是指向链表第一个结点的指针。使用"x/20x $rdx"之后可以看见如下值：
0x405330 <node1>: 0x00000227 0x00000001 0x00405340 0x00000000
0x405340 <node2>: 0x0000017d 0x00000002 0x00405350 0x00000000
0x405350 <node3>: 0x00000200 0x00000003 0x00405360 0x00000000
0x405360 <node4>: 0x00000044 0x00000004 0x00405370 0x00000000
0x405370 <node5>: 0x000003a5 0x00000005 0x00405210 0x00000000
这里我使用的测试值是1,2,3,4,5,6，所以是上述数值。由于linux是小端存储的，所以在看后面的"0x00405340 0x00000000"时，应当视作"0x0000000000405340"。而对于前面的值，可以看到第一列是给定值，而第二列是我们的输入值。
也就是说，结构体node可能是这样定义的：
struct node {
    int preset;
    int value;
    struct node* next;
};
此外，可以注意到<node5>中的指针指向一个新的不连续的空间，使用"x/4x 0x00405210"查看该位置可以得到：
0x405210 <node6>: 0x00000336 0x00000006 0x00000000 0x00000000
可以看见指针域是空指针，链表就此结束。
从<phase_6+120>到<phase_6+169>这一段也全部都是跳转语句，转换成C语言代码大致如下：
void phase_6_from_120_to_169() {
    node* node_arr = (void*)arr + 0x20;	/* 这其实是栈的一部分 */
    int p2 = 0;
    do {
        int p4 = arr[p2];  /* arr里面的前6个就存储着输入的6个整数 */
        int ret = 1;
        node* p3 = &node1; /* 之前分析的0x405330 <node1> */
        if (p4 > 1) {
            do {
                p3 = p3->next;
                ret += 1;
            }
            while (p4 != ret);
        }
        node_arr[p2] = p3;
        ++p2;
    }
    while (p2 != 6);
}
可以看出来其大致的意思是你输入的值的序列就是结点存储的序列，例如，你输入1,3,6,2,5,4，那么就会依次在node_arr中存储第一个结点，第三个结点，第六个结点……
然后，从<phase+171>到<phase+221>的代码就是让原链表结点按照数组中相邻的结点的顺序依次连接，且最后一个结点元素的指针域置零。
重点在后面，后面的代码中%rbx会从第一个结点开始向后遍历链表，而%rax指向的结点永远会先于%rbx一个，也就是%rax=%rbx->next。而循环中有个判断条件是否满足的位置，如果不满足，则会调用explode_bomb()。
查看判断条件可以发现，它要求(%rbx->preset)>(%rax->preset)，也就是说，它要求链表的结点按照递增的顺序连接，因此可以得出输入值为：4 2 3 1 6 5。

secret_phase:
要进入隐藏的关卡，首先得要知道secret_phase到底在哪里进入。可以发现在<phase_defused>函数，也就是炸弹解除函数内存在"call <secret_phase>"的字眼。说明这是进入该关卡的入口。
<phase_defused>函数可以分为两个部分，从<secret_phase>到<secret_phase+67>是炸弹解除并向服务器发送消息的逻辑，但在<phase_defused+34>有一段比较当前是否已经解除了6个炸弹的逻辑，而满足这个逻辑就会在退出函数前进入后半部分<phase_defused+68>到<phase_defused+195>。
这部分包含了进入<secret_phase>的逻辑。首先这段函数会调用<__isoc99_sscanf@plt>，根据上面的经验，使用"x/s $rdi"显示"11 18"，而使用"x/s $rsi"显示"%d %d %s"。观察"11 18"，可以发现是第4题的答案，说明还需要往第四题的答案后面加入一个字符串。
接着该函数会调用<strings_not_equal>，输入"x/s $rsi"显示"DrEvil"，说明第四题的答案应该改为"11 18 DrEvil"。接着就可以进入<secret_phase>了。
进入secret_phase后，首先仍然是<readline>，接着就会调用<strtol@plt>，把字符串转换为长整型。接着比较转换后的数字是否在1到1001之间，不在这个范围内就会调用<explode_bomb>。
接着就会进入函数<fun7>，这个函数的第一个参数是输入值，第二个参数是一个地址，根据一旁的注释可以发现是"# 0x405250 <n1>"。
输入"x/56x $rdi"可以看见以下输出：
0x405250 <n1>:	0x00000024	0x00000000	0x00405270	0x00000000
0x405260 <n1+16>:	0x00405290	0x00000000	0x00000000	0x00000000
0x405270 <n21>:	0x00000008	0x00000000	0x004052f0	0x00000000
0x405280 <n21+16>:	0x004052b0	0x00000000	0x00000000	0x00000000
0x405290 <n22>:	0x00000032	0x00000000	0x004052d0	0x00000000
0x4052a0 <n22+16>:	0x00405310	0x00000000	0x00000000	0x00000000
0x4052b0 <n32>:	0x00000016	0x00000000	0x004051b0	0x00000000
0x4052c0 <n32+16>:	0x00405170	0x00000000	0x00000000	0x00000000
0x4052d0 <n33>:	0x0000002d	0x00000000	0x00405110	0x00000000
0x4052e0 <n33+16>:	0x004051d0	0x00000000	0x00000000	0x00000000
0x4052f0 <n31>:	0x00000006	0x00000000	0x00405130	0x00000000
0x405300 <n31+16>:	0x00405190	0x00000000	0x00000000	0x00000000
0x405310 <n34>:	0x0000006b	0x00000000	0x00405150	0x00000000
0x405320 <n34+16>:	0x004051f0	0x00000000	0x00000000	0x00000000
可以看出这些是二叉树的结点，结点的大小是32bytes。前8bytes是结点中的数据，接下来的8bytes是指向左子树的指针，接下来的8bytes是指向右子树的指针，最后8bytes都是空的。
转换成C语言结构体可以写成：
typedef struct n {
    long value;
    struct n* left;
    struct n* right;
    void* null;
} n;
观察这些数据，发现部分指针指向未显示的内存空间，其中最小的地址为0x405110，使用"x/64x 0x405110"可以得到：
0x405110 <n45>:	0x00000028	0x00000000	0x00000000	0x00000000
0x405120 <n45+16>:	0x00000000	0x00000000	0x00000000	0x00000000
0x405130 <n41>:	0x00000001	0x00000000	0x00000000	0x00000000
0x405140 <n41+16>:	0x00000000	0x00000000	0x00000000	0x00000000
0x405150 <n47>:	0x00000063	0x00000000	0x00000000	0x00000000
0x405160 <n47+16>:	0x00000000	0x00000000	0x00000000	0x00000000
0x405170 <n44>:	0x00000023	0x00000000	0x00000000	0x00000000
0x405180 <n44+16>:	0x00000000	0x00000000	0x00000000	0x00000000
0x405190 <n42>:	0x00000007	0x00000000	0x00000000	0x00000000
0x4051a0 <n42+16>:	0x00000000	0x00000000	0x00000000	0x00000000
0x4051b0 <n43>:	0x00000014	0x00000000	0x00000000	0x00000000
0x4051c0 <n43+16>:	0x00000000	0x00000000	0x00000000	0x00000000
0x4051d0 <n46>:	0x0000002f	0x00000000	0x00000000	0x00000000
0x4051e0 <n46+16>:	0x00000000	0x00000000	0x00000000	0x00000000
0x4051f0 <n48>:	0x000003e9	0x00000000	0x00000000	0x00000000
0x405200 <n48+16>:	0x00000000	0x00000000	0x00000000	0x00000000
可以发现这些结点都是叶结点。
最终可以得到一个二叉搜索树：
0x24
 |-----------------\
0x8               0x32
 |-------\         |---------\
0x6     0x16      0x2d      0x66
 |---\   |----\    |----\    |----\
0x1 0x7 0x14 0x23 0x28 0x2f 0x63 0x3e9

<fun7>函数会被递归调用，因此还是按照<phase_4>的思路，写出其大致的C语言代码：
int fun7(int input, n* node) {
    if (n == NULL) return -1;
    int tmp = n->value;
    if (tmp == input) return 0;
    if (tmp > input) {
        n = n->left;
        int ret = fun7(input, n);
        return ret * 2;
    }
    if (tmp < input) {
        n = n->right;
        int ret = fun7(input, n);
        return 2 * ret + 1;
    }
}
而<secret_phase>中调用<fun7>的代码块如下：
void secret_phase_partial(int input) {
    int ret = fun7(input, (n*)0x405250); // 根节点的地址
    if (ret != 0x4) explode_bomb();
}
综上，我们需要找到一个输入，让调用<fun7>的返回值为4。
首先，这个值肯定不能是树中不存在的值，因为不存在的值会导致最后的调用返回-1，在“归”的过程中，就不可能变成正数了。既然符合就返回0，因此肯定要借助tmp小于input时的+1行为，接着连续乘以两次2，这样来看，最后的值是7。

结语：
我使用的是bomb27，里面的内容会不太一样，不过整体思路是完全可以借鉴的。
整个实验做了我4天时间，每天都花了我超过5个小时去做，做出来实属不容易。

